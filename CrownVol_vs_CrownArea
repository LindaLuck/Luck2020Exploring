##########################################################################################
##
##  Crown volume vs. crown area: can they be used interchangeably?
##  Author: Linda Luck 05 Feb 2020
##
##########################################################################################


### House keeping ----
## clean workspace - ctrl+L
rm(list=ls())

## set working directory
setwd("C:/Users/lluck/OneDrive - Charles Darwin University/PhD/Data/R scripts/PhD scripts/Allometric_relationships/")

## load libraries
#if (!require(chngpt)) install.packages('chngpt')
library("ggplot2")
library("car")
library("caret")
library("visreg")
library("viridis")


### Load data ----
df <- read.csv(file = "raw/Litchie_2019.csv", header = TRUE, strip.white = TRUE)#, row.names=1)

## investigate data (old school)
head(df)
dim(df)
str(df)
summary(df)
names(df)

## change DBH to cm
df$DBHcm <- df$DBH*100




### 1. Visualization of raw data and transform data if needed ----


## histograms of variables
par(mfrow=c(1,2))
hist(df$CrownArea) 
hist(df$CrownVolume) # -> right skewed - might log transform?

# compare log to raw outcome value
df$LOG_CrownVolume <- log(df$CrownVolume)
df$LOG_CrownArea <- log(df$CrownArea)
hist(df$CrownVolume)
hist(df$LOG_CrownVolume) # -> looks better but need to investigate model performance with raw and log transform (below)
hist(df$CrownArea)
hist(df$LOG_CrownArea)
par(mfrow=c(1,1))


## raw data plot separating by species (if known)
# ggplot(df,aes(y=CrownVolume,x=CrownArea))+ geom_point(color='blue') +
#   geom_smooth(method='loess') + 
#   theme(text = element_text(size=16)) +
#   labs(title = "Crown volume v area for each species untransformed")+ xlab("Crwon Area")+ ylab("Crown Volume")+
#   facet_wrap(~species)

## raw data plot
ggplot(df,aes(y=CrownVolume,x=CrownArea))+ geom_point(color='blue') +
  geom_smooth(method='lm') + 
  theme(text = element_text(size=16)) +
  labs(title = "Crown volume v area untransformed")+ xlab("crown area")+ ylab("crown volume")
# -> seems to fit alright but log-log (below) looks better

## log area and volume
ggplot(df,aes(y=LOG_CrownVolume,x=CrownArea))+ geom_point(color='blue') +
  geom_smooth(method='lm') + 
  theme(text = element_text(size=16)) +
  labs(title = "Log crown volume v area")+ xlab("crown area")+ ylab("log crown volume") 
# -> points now arch and don't align as well to the line - raw fit probalby better, log doesn't seem to explain crown vol w crown area

## log area and log volume
ggplot(df,aes(y=LOG_CrownVolume,x=LOG_CrownArea))+ geom_point(color='blue') +
  geom_smooth(method='lm') + 
  theme(text = element_text(size=16)) +
  labs(title = "Log crown volume v log area")+ xlab("log crown area")+ ylab("log crown volume") 
# -> log-log plot looks best
# -> model seems to underestimate crown volume for very small and very large trees


# -> need to decide between raw model and log-log model



### 2. Summary statistics ----

## nonparametric Spearman correlations based on ranks
## used to summarise strength and direction of relationship
## spearman's rank compares ranked data rather than actual values
cor.test(df$CrownVolume,df$CrownArea, use="complete.obs", method="spearman") 
cor.test(df$LOG_CrownVolume,df$LOG_CrownArea, use="complete.obs", method="spearman") 
cor.test(df$CrownVolume,df$CrownArea, use="complete.obs", method="pearson") 
# -> highly significant p-value, rho (correlation coefficient) close to +1 indicates strong positive correlation
# -> both, spearman and peason look great



### 3. Regression model ----

## model of non-log crown volume 
m1 <- lm(CrownVolume ~ CrownArea, data=df) 
summary(m1)
# Coefficients:
#              Estimate Std. Error t value  Pr(>|t|)    
# CrownArea    4.24545    0.02627  161.61   <2e-16 ***
# -> coefficient estimate (1st column) means that for every 1 unit increase in Crown Area there is an average 0.99 unit increase in the Crown Volume
confint(m1) # 95% CI indicates better fit for non-log model (below)
#              2.5 %     97.5 %
# CrownArea    4.193892  4.297005
# -> above means that for every unit increase in the crown area we are 95% confident that the increase is between 4.19 and 4.29 units in the crown volume
# -> that's pretty neat


## model of log crwon volume - try log transformed though above indicates might not be best fit
m1_log <- lm(LOG_CrownVolume ~ CrownArea, data=df) 
summary(m1_log) # -> outcome log transformed, need to exponeniate the coefficient and interpret change as multiplicative 
#confint(m1_log) # not suitable for log models
exp(cbind(exp_coeff = coef(m1_log), confint(m1_log))) # -> for use with logged outcome (but not predictor) - exponentiates CIs

#              exp_coeff   2.5 %    97.5 %
# CrownArea    1.082241    1.076405 1.088108
# -> above means that for every unit increase in crown area, there is an average 1.08% increase in crown volume 
# -> "95%CI 1.08 to 1.09%" means that we are 95% confident that the increase is btw 1.08 and 1.09%


m1_log_log <- lm(LOG_CrownVolume ~ log(CrownArea), data=df) 
summary(m1_log_log) # -> outcome log transformed, need to exponeniate the coefficient and interpret change as multiplicative 
confint(m1_log_log) # _> interpretations needs to be adjusted as perbelow
# interpretation for logl-log model:
# for every 10% increase in crown vol (the log transformed predictor), 
# the crown area (log transformed outcome) increases by ((1.10)^coefficient of crown area â€“ 1) %
# e.g. if coefficient estimate of log-crown are is 1.167, it is (1.1^1.167)-1=0.117 or 11.7%
# thus for every 10% increase in crown vol, the crown area increases on average by 11.7%


# -> in the above raw data model, the increase is additive, while for the log/exp model below the increase is %, making them hard to compare
# -> To decide also compare fits (scatter plots and model fits) - at first glace the log-log model makes more sense



### 4. Model diagnostics https://www.statmethods.net/stats/rdiagnostics.html ----

# check for random pattern of residuals across fitted values (should be evenly distributed with no obvious patterns)
# check for no outliers or overly influential observations with a lot of leverage and high Cooks distance
par(mfrow=c(2,2))
plot(m1)
# -> strong slope in fitted vs resid, cluster in scale-location, strong outliers outside cook's distance
#plot(m1_log)
plot(m1_log_log)
# -> visible curve in resid vs fitted but not as bad, better spread in scale-location, no outlies outside cooks's distance
par(mfrow=c(1,1))

# -> distribution of residuals appears more structured in log model - raw model could perform better?
# -> log-log model show most randomly didtributed error
# --> some influential outliers in all models - might need investigating


## test excluding potential influential outlier from log-log model
# --> 1082 is a 2 m stick without branches. not much influence but maybe worth excluding?
df_no1082 <- df[-(300),]
dim(df_no1082)
# re-run model w/out outlier
m1_log_log_OR <- lm(LOG_CrownVolume ~ LOG_CrownArea, data=df_no1082) 
summary(m1_log_log)
confint(m1_log_log)
summary(m1_log_log_OR) 
confint(m1_log_log_OR) # -> doesn't change p, R2 or CI enough to bother
par(mfrow=c(2,2))
plot(m1_log_log_OR) # residual distribution also doesn't really change.
par(mfrow=c(1,1))
# -> removing outlier doesn't improve model performance much. will retain 1082


## check for a potential serial (spatial) autocorrelation
# in this case only use if records are spatially related, i.e. if consecutive tree numbers are likely to be situated close to each other (or X+Y)
# -> if most spikes within the dotted line means they are not statistically significant, i.e. data points are not highliy correlated (first spike can be ignored)
df_AC <- df # create new df for testing
df_AC$XY <- df_AC$TreeLocationX*df_AC$TreeLocationY # add x & y coords for continuous spatial ordering
library("tidyverse")
df_AC %>% arrange(XY) # re-order rows
ggplot(df_AC, aes(x = TreeLocationX, y = TreeLocationY, color = XY)) + geom_point() + scale_color_gradientn(colours = rainbow(5)) + coord_fixed() # plot to check spatial gradient
m1_log_log_AC <- lm(LOG_CrownVolume ~ LOG_CrownArea, data=df_AC) # redo choson model with ordered data
acf(resid(m1_log_log_AC), main="autocorrelation") # test for spatial correlation
# -> all spikes are within dashed line - no evidence of spatial correlation in crown vol/ area
# --> try ,800 (or number of samples) to see full data set


### 5. Plot effect ----

## visreg similar to ggplot regression but using established model
par(mfrow=c(1,2))
visreg(m1, xvar="CrownArea", ylab="CrownVolume", points=list(cex=1))
#visreg(m1_log, xvar="CrownArea", ylab="log_CrownVolume", points=list(cex=1)) # visreg automatic - but does not backtransform from log transformed outcome (below)
visreg(m1_log_log, xvar="LOG_CrownArea", ylab="log_CrownVolume", points=list(cex=1))
par(mfrow=c(1,1))
# -> log model seems to have better fit than raw model



### ! only necessary when comparing log and non-log model
### to backtransform - need to do manually:
# Generate new dataset which contains the explanatory variables you have in the lm()
preddata <- with(df, 
                 data.frame(CrownArea = seq(min(CrownArea), max(CrownArea), length = 200))
)
head(preddata) # = randomly generated data set within minimum and maximum values of original data set and predetermined lentgh

## Generate dataset for log transformed m1_log_log model
# calculate the lower and upper 95% CI based on predictions
preds_log <- predict(m1_log_log, newdata = preddata, se.fit = TRUE)
critval <- 1.96 ## approx 95% CI
upr_log <- preds_log$fit + (critval * preds_log$se.fit)
lwr_log <- preds_log$fit - (critval * preds_log$se.fit)
fit_log <- preds_log$fit
# exp estimated crown area to backtransform from log
exp_preds <- exp(fit_log)
exp_upr <- exp(upr_log)
exp_lwr <- exp(lwr_log)
# combine to dataset
preddata_m1_log <- data.frame(CrownArea=preddata$CrownArea, fitlog=exp_preds, lowerlog=exp_lwr, upperlog=exp_upr)


## Generate dataset for 2nd model m1 with no log transform
preds2 <- predict(m1, newdata = preddata, se.fit = TRUE)
critval <- 1.96 ## approx 95% CI
upr <- preds2$fit + (critval * preds2$se.fit)
lwr <- preds2$fit - (critval * preds2$se.fit)
fit <- preds2$fit
preddata_m1 <- data.frame(CrownArea=preddata$CrownArea, fit=fit, lower=lwr, upper=upr)

## plot to compare model fit
ggplot(aes(x=CrownArea, y=fit), data=preddata_m1) + 
  geom_line(size=0.5, color="blue") +
  geom_ribbon(data=preddata_m1,aes(ymin=lower,ymax=upper),alpha=0.3, fill="blue") +
  labs(x="crown area", y="fitted crown volume") + theme_bw() +
  geom_point(aes(x=CrownArea, y=CrownVolume), data=df, size=2, alpha = 0.5) +
  geom_line(aes(x=CrownArea, y=fitlog), data=preddata_m1_log, size=0.5, color="red") +
  geom_ribbon(data=preddata_m1_log,aes(ymin=lowerlog,ymax=upperlog),alpha=0.3, fill="red")
#theme(legend.position=c(1, 0))
# -> linear fit better fit compared to log

# focus on where bulk of data is
ggplot(aes(x=CrownArea, y=fit), data=preddata_m1) +
  geom_line(size=0.5, color="blue") +
  geom_ribbon(data=preddata_m1,aes(ymin=lower,ymax=upper),alpha=0.3, fill="blue")+
  labs(x="CrownArea", y="fitted CrownVolume") + theme_bw() +
  geom_point(aes(x=CrownArea, y=CrownVolume), data=df, size=2, alpha = 0.5) +
  geom_line(aes(x=CrownArea, y=fitlog), data=preddata_m1_log, size=0.5, color="red") +
  geom_ribbon(data=preddata_m1_log,aes(ymin=lowerlog,ymax=upperlog),alpha=0.3, fill="red")+
  scale_x_continuous(limits=c(0,20)) +
  scale_y_continuous(limits=c(0,80))

# -> log plot fits majority of points which are located at lower end; but doesn't explain higher values well
# -> linear plot completely misses the point
# -> could be another change poit at about 25?

### Test change point regression ----

# segmented

m1_seg <- chngptm(formula.1= CrownVolume ~ 1, formula.2=~CrownArea, data = df, type="segmented", family="gaussian")
summary(m1_seg)
# -> test data shows a lot of spread between lower and upper confidence interval after change point
plot(m1_seg)
# MLR test whether there is a change point 
testresult_m1_seg <- chngpt.test(formula.null=CrownVolume~1, formula.chngpt=~CrownArea, df, type="segmented", family="gaussian")
testresult_m1_seg

## get estimate of slope after threshold
est_m1_seg=lincomb(m1_seg, comb=c(0,1,1), alpha=0.05); print(est_m1_seg)

# -> For every unit increase in CrownArea there is a 1.89 (95%CI 1.25 - 2.53, P < 0.001) unit increase in crown volume 
# -> until a change point at 16.76 m2 CrownArea (95%CI 10.41 - 23.11)
# -> from that change point the increase in crown volume per unit CrownArea increases to 4.96 (95%CI 4.60 - 5.32, P < 0.001)



### 6. Pretty plot for selected model ----

### try k-fold model to extract errors
library(caret)

### resample data
set.seed(123)
train.control <- trainControl(method = "repeatedcv", 
                              number = 10, repeats = 3)

### Train the model

set.seed(123)
m1_log_log_k <- train(LOG_CrownVolume ~ log(CrownArea), data = df, method = "lm",
                      trControl = train.control)

## check difference

summary(m1_log_log_k)
summary(m1_log_log) # compare to normal model


### export model performance

summary_m1_k <- print(m1_log_log_k)

R2_m1 <- as.numeric(summary_m1_k[[2]])
lab_m1 <- paste("R2 = ", format(round(R2_m1, 2), nsmall = 2))
RMSE_m1 <- as.numeric(summary_m1_k[[1]])
lab_RMSE_m1 <- paste("RMSE = ", format(round(RMSE_m1, 2), nsmall = 2), "cm")
MAE_m1 <- as.numeric(summary_m1_k[[3]])
lab_MAE_m1 <- paste("MAE = ", format(round(MAE_m1, 2), nsmall = 2), "cm")

lab_m1 <- paste(lab_m1,lab_RMSE_m1,lab_MAE_m1, sep = "\n")



### plot results

ggplot(data = preddata_m1, aes(x = CrownArea, y = fit)) +
  geom_point(aes(x=CrownArea, y=CrownVolume), data=df, size=2, alpha = 0.5) +
  geom_line(aes(x=CrownArea, y=fitlog), data=preddata_m1_log, size=0.5, color="blue") +
  geom_ribbon(data=preddata_m1_log,aes(ymin=lowerlog,ymax=upperlog),alpha=0.3, fill="blue") +
  annotate(geom = "text", x = min(preddata_m1_log$CrownArea), y = max(preddata_m1_log$fit), 
           label = lab_m1, hjust = 0, vjust = 1, lineheight = 1) +
  #ggtitle("pretty plot") +
  labs(x="Crown area", y="Fitted crown volume") +
  theme_bw() +
  theme(panel.grid=element_blank()) +
  theme(panel.border = element_blank()) +
  theme(axis.line.x = element_line(color="black", size = 0.5),
        axis.line.y = element_line(color="black", size = 0.5)) #+
  scale_x_continuous(limits=c(0,15)) +
  scale_y_continuous(limits=c(0,40))

# RMSE = root mean square error 
## -> gives higher weight to large errors - more sensitive to strong outliers. with lots of variation in savanna maybe less usefull
## -> "RMSE does not necessarily increase with the variance of the errors. RMSE increases with the variance of the frequency distribution of error magnitudes."
## -> https://medium.com/human-in-a-machine-world/mae-and-rmse-which-metric-is-better-e60ac3bde13d

# MAE - mean absolute error
# -> MAE < RMSE indicates there are some strong outliers
